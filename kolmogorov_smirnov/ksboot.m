function [p, ksstat_sample, ksstat_boot] = ksboot(sample, model, nboot)
% Kolmogorov-Smirnov test if a sample is generated by a continuous
% distribution function (model) which parameters are estimated from the sample
%
%SYNOPSYS
% [p, ksstat_sample, ksstat_boot] = KSBOOT(sample, model, nboot)
%
%INPUT
% sample        /vector/ of observations/realizations
% model         /string/ specifying the distribution type, implemented models:
%               'normal', 'lognormal2', 'gumbel', 'lognormal3',
%               'gev', 'w3max' 'w3min'
%
%OPTIONAL
% nboot         number of simulations (bootstrap) to construct the test distribution
%               /integ; default is 1e3/
%
%OUTPUT
% p             p value of the test /scalar/
% kstat_sample  test statistics of the sample /scalar/
% kstat_boot    test statistics from bootstrap /vector/
%
% NOTES:
% * the sampling distribution (null distribution) is constructed by boostrapping
% maximum likleihood fit with the excpetion of normal and lognormal distributions
% for those method of moment fit (should be extended)

% * 'smooth' bootstrapping, that is sampling from the empirical cumulative
%   distribution function with linear interpolation between points and not
%   extrapolating outside of the datarange
% * the empirical distribution function is constructed with plotting position
%   recommended by Cunnane, C. (1978) Unbiased plotting positions — A review. Journal of Hydrology

% TODO
% * Generalize the model calling: random number generation and cdf handlers
% could be passed as input
% * resolve dependency on kstest.m
% * parameter estimation should be consistent among models

if nargin < 3
    nboot = 1e3;
end

if nargin < 2
    error('The sample and model arguments must be given!')
end

sample  = sample(:);
nsample = numel(sample);

% empiF   = ((1:nsample)-2/5)./(nsample + 1/5);
% s_sample= sort(sample);

options = optimset('MaxFunEvals', 4e3, ...
    'MaxIter', 2e3, ...
    'TolFun', 1e-8, ...
    'TolX', 1e-8);

% evaluate the model
switch lower(model)
    case 'gev'
        parm_hat = gevfit(sample, options);
        r_model = @(m,n) gevrnd(parm_hat(1), parm_hat(2), parm_hat(3), m, n);
        
        F = gevcdf(sample, parm_hat(1), parm_hat(2), parm_hat(3));
        [~,~,ksstat_sample] = kstest(sample, 'CDF', [sample, F]);
    case 'w3max'       
        parm_hat = fit_w3max_mle(sample);
        r_model = @(m,n) w3maxrnd(parm_hat(1), parm_hat(2), parm_hat(3), m, n);
        
        F = w3maxcdf(sample, parm_hat(1), parm_hat(2), parm_hat(3));       
        [~,~,ksstat_sample] = kstest(sample, 'CDF', [sample, F]);
    case 'w3min'
        parm_hat = fit_w3min_mle(sample);
        r_model = @(m,n) w3minrnd(parm_hat(1), parm_hat(2), parm_hat(3), m, n);
        
        F = w3mincdf(sample, parm_hat(1), parm_hat(2), parm_hat(3));
        [~,~,ksstat_sample] = kstest(sample, 'CDF', [sample, F]);
    case {'gum', 'gumb', 'gumbel'}
        parm_hat = fit_gumbel_mle(sample, 'par');
        r_model = @(m,n) gevrnd(0, parm_hat(1), parm_hat(2), m, n);
        
        F = gevcdf(sample, 0, parm_hat(1), parm_hat(2));
        [~,~,ksstat_sample] = kstest(sample, 'CDF', [sample, F]);
    case 'ln3'
        parm_hat = fit_lognorm3_mle(sample);
        r_model = @(m,n) lognorm3rnd(parm_hat(1), parm_hat(2), parm_hat(3), m, n);
        
        F = lognorm3cdf(sample, parm_hat(1), parm_hat(2), parm_hat(3));
        [~,~,ksstat_sample] = kstest(sample, 'CDF', [sample, F]);
    case {'lognormal', 'ln2'}
        r_model = @(m,n) lognormrnd(mean(sample), std(sample)/mean(sample), m, n);
        
        F = lognormcdf(sample, mean(sample), std(sample)/mean(sample));
        [~,~,ksstat_sample] = kstest(sample, 'CDF', [sample, F]);
    case 'normal'
        r_model = @(m,n) normrnd(mean(sample), std(sample), m, n);
        
        F = normcdf(sample, mean(sample), std(sample));
        [~,~,ksstat_sample] = kstest(sample, 'CDF', [sample, F]);
    otherwise
        error(['Unknown model: ', model])
end

% draw _nboot_ number of random samples of size _nsample_ from the model
RM = r_model(nsample, nboot);

ksstat_boot = nan(nboot,1);
tic
parfor ii = 1:nboot
    xx = RM(:,ii);
    switch lower(model)
        case 'gev'
            parm_hat = gevfit(xx, options);
            FF = gevcdf(xx, parm_hat(1), parm_hat(2), parm_hat(3));
        case 'w3max'
            parm_hat = fit_w3max_mle(xx);
            FF = w3maxcdf(xx, parm_hat(1), parm_hat(2), parm_hat(3));
        case 'w3min'
            parm_hat = fit_w3min_mle(xx);
            FF = w3mincdf(xx, parm_hat(1), parm_hat(2), parm_hat(3));
        case 'gumbel'
            parm_hat = fit_gumbel_mle(xx, 'par');
            FF = gevcdf(xx, 0, parm_hat(1), parm_hat(2));
        case 'ln3'
            parm_hat = fit_lognorm3_mle(xx);
            FF = lognorm3cdf(xx, parm_hat(1), parm_hat(2), parm_hat(3));
        case {'lognormal', 'ln2'}
            m = mean(xx);
            c = std(xx)/m;
            FF = lognormcdf(xx, m, c);
        case 'normal'
            FF = normcdf(xx, mean(xx), std(xx));
        otherwise
            error(['Unknown model: ', model])
    end
    
    [~,~,ksstat_boot(ii)] = kstest(xx, 'CDF', [xx, FF]);
end
toc

% p = sum(p_boot>p_sample)/nboot;
p = sum(ksstat_boot>ksstat_sample)/nboot;

disp(['Approximate standard error of p: ', num2str(p/sqrt(nboot))])

end